<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>SCC Models</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">SCC Models</h1>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(epicmodel)</span></code></pre></div>
<p>Sufficient-component cause (SCC) models are the core of the
<code>epicmodel</code> package. Creating this package came with
interesting discoveries and (re-)interpretations of some underlying
concepts. They arise, first and foremost, from the definition of the
steplist as well as the model creation process from steplist to SCC
model. This vignette tries to summarize what “this thing called SCC
model” is to <code>epicmodel</code>.</p>
<ul>
<li>This vignette touches on concepts described in
<code>vignette(&quot;steplist&quot;)</code>.</li>
<li>For a detailed description of the structure of SCC objects from a R
perspective, see <code>?new_scc</code>.</li>
<li>And as always, Rothman’s paper is highly recommended (Rothman
1976).</li>
</ul>
<div id="why-scc" class="section level1">
<h1>Why SCC?</h1>
<p>Before going into more specific topics, it is worth clarifying what
the purpose of a SCC model actually is. As previously described, they
are a <strong>causal modeling framework</strong>, i.e., a specific
structure or an approach to causal modeling, i.e., to specifying and
structuring causal assumptions. As we learned from Pearl (2009;
pp. 38-40), causal inference is only possible based on causal
assumptions and, therefore, causal inference methods need to include
causal modeling. There are different causal modeling frameworks
available, e.g., causal graphs in the form of directed acyclic graphs
(DAG). Different frameworks usually have different perspectives and can
complement each other.</p>
<p>SCC models describe a single outcome of interest, but with all of its
(known or suspected) causes, which makes it an outcome-focused approach.
The SCC framework models the idea that an effect has multiple causes and
that only certain combinations of these causes lead to the outcome. The
individual causes are called “component causes”, further emphasizing
that multiple causes are necessary for the outcome to occur. The
combinations of component causes that can lead to the outcome of
interest are called “sufficient causes”, emphasizing that each of these
sets is enough to cause the outcome. The main modeling task is grouping
component causes together to form sufficient causes.</p>
<p>SCC models add an important perspective to causal modeling and
therefore to causal inference. Here is, as an example, a quote from an
article by Rerknimitr et al. (2017) talking about atopic dermatitis (AD)
and filaggrin (FLG):</p>
<blockquote>
<p>Although null mutation of the FLG gene poses the strongest risk for
AD, 60% of individuals who carry the gene do not have AD symptoms
(Irvine et al. 2011). On the contrary, a significant portion of AD
patients do not have FLG mutation (Irvine et al. 2011). It is thus
evident that additional factors are needed to develop the disease.</p>
</blockquote>
<p>Through a SCC lens, the case seems obvious: Null mutations of the FLG
gene seem to be a component cause for atopic dermatitis, but they are
not part of every sufficient cause. An intuitive understanding of the
SCC structure seems especially useful when investigating the effect of
interventions. A certain intervention might be very beneficial for
certain sufficient causes, i.e., a certain group of affected
individuals, but useless for others. Without considering this
possibility, the effect of beneficial interventions might be easily
missed.</p>
<p>The purpose of SCC models is therefore to extend causal modeling
practices by the SCC perspective, which emphasizes two main points:</p>
<ul>
<li>A single cause is only a component of a causal mechanism. For the
outcome to occur, other complementary component causes are needed.</li>
<li>There are multiple mechanisms that can lead to outcome occurrence. A
single cause is usually not part of all mechanisms.</li>
</ul>
<p>The task of SCC model creation can therefore be rephrased to the task
of finding the smallest sets of component causes that are sufficient for
outcome occurrence, with “smallest” meaning that, within the sufficient
set, every single component cause is necessary. In
<code>epicmodel</code>, these smallest sets are sometimes explicitly
called <strong>minimally sufficient</strong>, even though sufficiency
implies “minimality” by definition.</p>
</div>
<div id="how-can-scc-models-be-used" class="section level1">
<h1>How can SCC models be used?</h1>
<p>The functionalities available in <code>epicmodel</code> show how SCC
models might be used in practice. As mentioned above, SCC models are
outcome-focused and in theory need to include all causes of an outcome.
Their creation is therefore time-consuming, but once created, they
should be easily re-usable. <code>epicmodel</code> is built on the
assumption that we know enough about many health outcomes to create
useful SCC models. A useful SCC model might be able to fulfill the
following tasks:</p>
<ul>
<li>Increase understanding of the modeled health outcome by grouping
component causes to sufficient causes</li>
<li>Generate hypotheses about the effect of prevention and
interventions</li>
<li>Form the backbone of complex epidemiological causal models by
translating the SCC model to a DAG</li>
</ul>
</div>
<div id="algorithm-for-scc-model-creation" class="section level1">
<h1>Algorithm for SCC model creation</h1>
<p>First, let’s briefly talk about the algorithm for SCC model creation.
The details are described in the function documentation for
<code>create_scc()</code>. These are the basic steps:</p>
<ol style="list-style-type: decimal">
<li>Derive a list of all valid combinations of component causes</li>
<li>Check all valid combinations of component causes for sufficiency (at
this point, IFNOT conditions are ignored)</li>
<li>Check if IFNOT conditions influence sufficiency</li>
<li>Reduce list of sufficient causes to minimally sufficient causes</li>
<li>Add unknown causes</li>
</ol>
</div>
<div id="ifnot-conditions-sufficiency-status-and-the-concept-of-time" class="section level1">
<h1>IFNOT conditions, sufficiency status, and the concept of time</h1>
<p>While talking about the induction period in SCC models, Rothman et
al. (2008; pp. 15-16) write:</p>
<blockquote>
<p>There is no way to tell from a pie-chart diagram of a sufficient
cause which components affect each other, which components must come
before or after others, for which components the temporal order is
irrelevant, etc. The crucial information on temporal ordering must come
in a separate description of the interrelations among the components of
a sufficient cause.</p>
</blockquote>
<p>These interrelations among the component causes are available in the
steplist, because the steps are based on mechanisms of outcome
occurrence, which predefines their temporal ordering, i.e., the IF
condition of a step always occurs before the corresponding THEN
statement. For IFNOT conditions, however, this is not necessarily the
case. The IFNOT condition could be fulfilled before or after the IF
condition. Importantly, the temporal order of IF and IFNOT makes a
difference. Under the implicit assumption that IF instantly leads to
THEN, there are two possible orders of occurrence for steps with both IF
and IFNOT conditions fulfilled:</p>
<ul>
<li>IF -&gt; THEN -&gt; IFNOT: IF and therefore THEN occur before IFNOT
is fulfilled. Therefore, even if IFNOT is fulfilled, it cannot prevent
THEN.</li>
<li>IFNOT -&gt; IF: IFNOT occurs before IF and therefore IFNOT prevents
THEN from happening, even though IF is fulfilled.</li>
</ul>
<p>Importantly, the steplist does not contain information on which of
these two orders of occurrence are realistic or if both are possible.
Therefore, the algorithm of SCC model creation makes sure that all
possible temporal orders are investigated. This is the reason, why the
algorithm starts with ignoring IFNOT.</p>
<p>It is worth mentioning, that it is implicitly assumed that, once a
step occurred, it stays until the end, e.g., if step “IF Cell A produces
cytokine B THEN cytokine B is present” occurred, cytokine B will be
present until the end. If this assumption is unrealistic, an IFNOT
condition needs to be added: “IF Cell A produces cytokine B and IFNOT
factor C removes cytokine B THEN cytokine B is present”.</p>
<p>In the quote, Rothman et al. speak of a separate description of the
crucial information on temporal ordering in addition to the pie-chart
diagram. In <code>epicmodel</code>, this separate description takes the
form of the <strong>sufficiency status</strong>. The sufficiency status
describes for every sufficient cause, if it is always sufficient or if
sufficiency depends on the order of occurrence of some of its elements.
See also <code>?new_scc</code> for more information.</p>
<p>Let’s look at the built-in <code>steplist_party</code> as an example.
It describes the situation of our friend Clara who is wondering under
which circumstances her birthday party will be a success. Let’s first
load the steplist, check it (after some adjustments), and create the SCC
model.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>steplist_checked <span class="ot">&lt;-</span> steplist_party <span class="sc">%&gt;%</span> <span class="fu">remove_na</span>() <span class="sc">%&gt;%</span> <span class="fu">remove_segment</span>(<span class="st">&quot;d4&quot;</span>) <span class="sc">%&gt;%</span> <span class="fu">check_steplist</span>()</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>scc_model <span class="ot">&lt;-</span> steplist_checked <span class="sc">%&gt;%</span> <span class="fu">create_scc</span>()</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>scc_model</span></code></pre></div>
<pre><code>#&gt; 
#&gt; ── Outcome Definitions ──
#&gt; 
#&gt; • Emma is coming and food is fine and Laura is coming and weather is fine
#&gt; 
#&gt; ── SC 1 ──
#&gt; 
#&gt; ✔ Always sufficient
#&gt; Component causes:
#&gt; • Emma is invited
#&gt; • Laura is invited
#&gt; • Birthday party takes place on a weekday
#&gt; • Birthday party takes place at a karaoke bar
#&gt; 
#&gt; Modules
#&gt; • guests: 40% (4/10)
#&gt; • orga: 40% (4/10)
#&gt; • food: 20% (2/10)
#&gt; 
#&gt; ── SC 2 ──
#&gt; 
#&gt; ✔ Always sufficient
#&gt; Component causes:
#&gt; • Ana is invited
#&gt; • Emma is invited
#&gt; • Laura is invited
#&gt; • Birthday party takes place at a restaurant
#&gt; 
#&gt; Modules
#&gt; • guests: 60% (6/10)
#&gt; • orga: 30% (3/10)
#&gt; • food: 10% (1/10)
#&gt; 
#&gt; ── SC 3 ──
#&gt; 
#&gt; ! Sufficiency depends on order of occurrence
#&gt; Component causes:
#&gt; • Ana is invited
#&gt; • Emma is invited
#&gt; • Laura is invited
#&gt; • Birthday party takes place on a weekday
#&gt; • No rain
#&gt; • Birthday party takes place at the beach
#&gt; 
#&gt; Sufficient orders of occurrence:
#&gt; • Ana is invited -&gt; birthday party takes place on a weekday
#&gt; 
#&gt; Modules
#&gt; • guests: 46% (6/13)
#&gt; • orga: 38% (5/13)
#&gt; • food: 15% (2/13)
#&gt; </code></pre>
<p>In the output, the sufficiency status is displayed as first element
of a sufficient cause (SC). For SC1 and SC2, the status is “Always
sufficient”. The status of SC3, however, is reported as “Sufficiency
depends on order of occurrence”. The reason is that the mechanism of SC3
contains the following step: <em>IF Ana is invited and IFNOT birthday
party takes place on a weekday THEN Ana is coming</em>. We can see from
the list of component causes in the output that both IF and IFNOT are
fulfilled in SC3. Therefore, the algorithm checks, which orders of
occurrence are sufficient for outcome occurrence and which are not. In
this case, there are only two options:</p>
<ol style="list-style-type: decimal">
<li>Ana is invited -&gt; birthday party takes place on a weekday</li>
<li>birthday party takes place on a weekday -&gt; Ana is invited</li>
</ol>
<p>In the output, below the list of component causes, the sufficient
orders of occurrence are listed. Here only option 1 is sufficient,
because “Ana is invited” is the IF condition and must occur before the
IFNOT condition “birthday party takes place on a weekday”.</p>
<p>You probably noticed that in this example, these orders of occurrence
do not make much sense. Even if Ana is invited before the host decides
that the party takes place on a weekday, she still wouldn’t go. The
problem occurs because the aforementioned assumption that IF instantly
leads to THEN is violated. Therefore, you as the user need to evaluate
if the orders of occurrence are plausible or not. <code>epicmodel</code>
is able to notice some implausibilities and will report their presence
in the output below the sufficiency status. However, even in this case
there are always all possible orders of occurrence evaluated and
reported and the user needs to discard implausible ones. In our birthday
party example, we need to discard the only sufficient order of
occurrence, which means that SC3 is actually not a sufficient cause!
When creating causal pies, we can address this issue by specifying the
<code>remove_sc</code> argument of <code>plot()</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">plot</span>(scc_party, <span class="at">remove_sc =</span> <span class="dv">3</span>)</span></code></pre></div>
</div>
<div id="unknown-causes" class="section level1">
<h1>Unknown causes</h1>
<p>The final step of the aforementioned algorithm is called “Add unknown
causes”. As described above, a SCC model must, in theory, contain all
causes, component causes as well as sufficient causes, of the outcome of
interest. In practice, knowing all causes is of course unrealistic.
<code>create_scc()</code> therefore adds unknown causes as placeholders.
Two types of unknown causes are added (see also
<code>?new_scc</code>):</p>
<ul>
<li>Unknown component cause: One additional component cause is added to
every sufficient cause to represent the set of unknown component causes.
Every sufficient cause gets a unique unknown component cause.</li>
<li>Unknown sufficient cause: One additional sufficient cause with a
single component cause is added to represent all unknown sufficient
causes.</li>
</ul>
<p>You can decide to not include unknown causes in all relevant
functions by setting <code>unknown = FALSE</code>, for example when
plotting causal pies with <code>plot()</code>.</p>
</div>
<div id="other-functions-for-scc-models" class="section level1">
<h1>Other functions for SCC models</h1>
<p><code>epicmodel</code> offers additional functions to inspect SCC
models created by <code>create_scc()</code>. For functions that use or
further process SCC models, see “Get started” (i.e.,
<code>vignette(&quot;epicmodel&quot;)</code>).</p>
<div id="print-all-step-ids-and-descriptions" class="section level2">
<h2>Print all step IDs and descriptions</h2>
<p>Use <code>show_steps()</code> to print step IDs and descriptions in
the console.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">show_steps</span>(scc_model)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="co">#&gt; • THENa5d1: Start: Ana is invited</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="co">#&gt; • THENa4d1: Start: Emma is invited</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="co">#&gt; • THENa6d1: Start: Laura is invited</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co">#&gt; • THENa7d3e3: Start: Birthday party takes place on a weekday</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co">#&gt; • IFa5d1IFNOTa7d3e3THENa5d5: IF Ana is invited and IFNOT birthday party takes</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="co">#&gt; place on a weekday THEN Ana is coming</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co">#&gt; • THENa3: Start: No rain</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co">#&gt; • THENa7d3e4: Start: Birthday party takes place at a restaurant</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="co">#&gt; • THENa7d3e5: Start: Birthday party takes place at a karaoke bar</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a><span class="co">#&gt; • IF(a7d3e2)or(a7d3e1+a3)THENa2d6: End: IF birthday party takes place inside or</span></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a><span class="co">#&gt; (birthday party takes place outside and no rain) THEN weather is fine</span></span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a><span class="co">#&gt; • IF(a7d3e5)or(a7d3e4)THENa7d3e2: IF birthday party takes place at a karaoke</span></span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a><span class="co">#&gt; bar or birthday party takes place at a restaurant THEN birthday party takes</span></span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a><span class="co">#&gt; place inside</span></span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a><span class="co">#&gt; • THENa7d3e6: Start: Birthday party takes place at the beach</span></span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a><span class="co">#&gt; • IFa7d3e6THENa7d3e1: IF birthday party takes place at the beach THEN birthday</span></span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a><span class="co">#&gt; party takes place outside</span></span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a><span class="co">#&gt; • IFa6d1THENa6d5: End: IF Laura is invited THEN Laura is coming</span></span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a><span class="co">#&gt; • IF(a4d1+a5d5)or(a4d1+a7d3e5)THENa4d5: End: IF (Emma is invited and Ana is</span></span>
<span id="cb5-21"><a href="#cb5-21" tabindex="-1"></a><span class="co">#&gt; coming) or (Emma is invited and birthday party takes place at a karaoke bar)</span></span>
<span id="cb5-22"><a href="#cb5-22" tabindex="-1"></a><span class="co">#&gt; THEN Emma is coming</span></span>
<span id="cb5-23"><a href="#cb5-23" tabindex="-1"></a><span class="co">#&gt; • IFa7d3e3THENa8d2a1: IF birthday party takes place on a weekday THEN Clara,</span></span>
<span id="cb5-24"><a href="#cb5-24" tabindex="-1"></a><span class="co">#&gt; the host, brings birthday cake</span></span>
<span id="cb5-25"><a href="#cb5-25" tabindex="-1"></a><span class="co">#&gt; • IF(a7d3e4)or(a8d2a1)THENa9d6: End: IF birthday party takes place at a</span></span>
<span id="cb5-26"><a href="#cb5-26" tabindex="-1"></a><span class="co">#&gt; restaurant or Clara, the host, brings birthday cake THEN food is fine</span></span></code></pre></div>
</div>
<div id="inspect-if-sufficient-causes-contain-certain-steps" class="section level2">
<h2>Inspect if sufficient causes contain certain steps</h2>
<p>When printing SCC models, it is reported, which component causes are
part of the sufficient causes. However, sometimes you might want to know
if some other step is part of the mechanism that links component causes
and outcome for sufficient causes. Use <code>sc_contain_steps()</code>
to get the answer. When talking about the sufficiency status above, we
were interested in the step <em>IF Ana is invited and IFNOT birthday
party takes place on a weekday THEN Ana is coming</em>. So let’s
double-check if it is actually only part of sufficient cause 3. The
corresponding step ID, as we see from <code>show_steps()</code> is
<em>IFa5d1IFNOTa7d3e3THENa5d5</em>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>scc_model <span class="sc">%&gt;%</span> <span class="fu">sc_contain_steps</span>(<span class="st">&quot;IFa5d1IFNOTa7d3e3THENa5d5&quot;</span>)</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co">#&gt; ── SC 1 ──</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">#&gt; Component causes:</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">#&gt; • Emma is invited</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co">#&gt; • Laura is invited</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co">#&gt; • Birthday party takes place on a weekday</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a><span class="co">#&gt; • Birthday party takes place at a karaoke bar</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a><span class="co">#&gt; ✖ SC1 does not contain step &#39;IF Ana is invited and IFNOT birthday party takes place on a weekday THEN Ana is coming&#39; (IFa5d1IFNOTa7d3e3THENa5d5)</span></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a><span class="co">#&gt; ── SC 2 ──</span></span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a><span class="co">#&gt; Component causes:</span></span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a><span class="co">#&gt; • Ana is invited</span></span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a><span class="co">#&gt; • Emma is invited</span></span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a><span class="co">#&gt; • Laura is invited</span></span>
<span id="cb6-19"><a href="#cb6-19" tabindex="-1"></a><span class="co">#&gt; • Birthday party takes place at a restaurant</span></span>
<span id="cb6-20"><a href="#cb6-20" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-21"><a href="#cb6-21" tabindex="-1"></a><span class="co">#&gt; ✔ SC2 contains step &#39;IF Ana is invited and IFNOT birthday party takes place on a weekday THEN Ana is coming&#39; (IFa5d1IFNOTa7d3e3THENa5d5)</span></span>
<span id="cb6-22"><a href="#cb6-22" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-23"><a href="#cb6-23" tabindex="-1"></a><span class="co">#&gt; ── SC 3 ──</span></span>
<span id="cb6-24"><a href="#cb6-24" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-25"><a href="#cb6-25" tabindex="-1"></a><span class="co">#&gt; Component causes:</span></span>
<span id="cb6-26"><a href="#cb6-26" tabindex="-1"></a><span class="co">#&gt; • Ana is invited</span></span>
<span id="cb6-27"><a href="#cb6-27" tabindex="-1"></a><span class="co">#&gt; • Emma is invited</span></span>
<span id="cb6-28"><a href="#cb6-28" tabindex="-1"></a><span class="co">#&gt; • Laura is invited</span></span>
<span id="cb6-29"><a href="#cb6-29" tabindex="-1"></a><span class="co">#&gt; • Birthday party takes place on a weekday</span></span>
<span id="cb6-30"><a href="#cb6-30" tabindex="-1"></a><span class="co">#&gt; • No rain</span></span>
<span id="cb6-31"><a href="#cb6-31" tabindex="-1"></a><span class="co">#&gt; • Birthday party takes place at the beach</span></span>
<span id="cb6-32"><a href="#cb6-32" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-33"><a href="#cb6-33" tabindex="-1"></a><span class="co">#&gt; ✔ SC3 contains step &#39;IF Ana is invited and IFNOT birthday party takes place on a weekday THEN Ana is coming&#39; (IFa5d1IFNOTa7d3e3THENa5d5)</span></span></code></pre></div>
<p>Actually, the step is part of both SC2 and SC3. This makes complete
sense because, in contrast to SC1, Ana is invited both times and
therefore the IF condition is fulfilled. Only SC3 has status
“Sufficiency depends on order of occurrence” because the IFNOT condition
is only fulfilled in SC3 but not in SC2.</p>
</div>
<div id="get-component-causes-as-list" class="section level2">
<h2>Get component causes as list</h2>
<p>If you want to retrieve the sets of component causes that form the
sufficient causes as a list of vectors, you can use
<code>scc_cause_sets()</code>. You can retrieve both step IDs as well as
descriptions.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>scc_model <span class="sc">%&gt;%</span> <span class="fu">scc_cause_sets</span>(<span class="at">output =</span> <span class="st">&quot;desc&quot;</span>)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="co">#&gt; $cc90</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="co">#&gt; [1] &quot;Start: Emma is invited&quot;                            </span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co">#&gt; [2] &quot;Start: Laura is invited&quot;                           </span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="co">#&gt; [3] &quot;Start: Birthday party takes place on a weekday&quot;    </span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co">#&gt; [4] &quot;Start: Birthday party takes place at a karaoke bar&quot;</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="co">#&gt; $cc103</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="co">#&gt; [1] &quot;Start: Ana is invited&quot;                            </span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co">#&gt; [2] &quot;Start: Emma is invited&quot;                           </span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="co">#&gt; [3] &quot;Start: Laura is invited&quot;                          </span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a><span class="co">#&gt; [4] &quot;Start: Birthday party takes place at a restaurant&quot;</span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a><span class="co">#&gt; $cc125</span></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a><span class="co">#&gt; [1] &quot;Start: Ana is invited&quot;                         </span></span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a><span class="co">#&gt; [2] &quot;Start: Emma is invited&quot;                        </span></span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a><span class="co">#&gt; [3] &quot;Start: Laura is invited&quot;                       </span></span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a><span class="co">#&gt; [4] &quot;Start: Birthday party takes place on a weekday&quot;</span></span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a><span class="co">#&gt; [5] &quot;Start: No rain&quot;                                </span></span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a><span class="co">#&gt; [6] &quot;Start: Birthday party takes place at the beach&quot;</span></span></code></pre></div>
</div>
<div id="check-sufficiency-for-a-set-of-component-causes" class="section level2">
<h2>Check sufficiency for a set of component causes</h2>
<p>Finally, with <code>are_sufficient()</code> you can check for a given
SCC model if a certain set of component causes would lead to the outcome
of interest, i.e., if any sufficient cause is fulfilled by your provided
set. There are two types of output: <code>type = &quot;binary&quot;</code>,
returns <code>TRUE</code> or <code>FALSE</code>, while
<code>type = &quot;status&quot;</code> returns one of “always”, “depends”, or
“never”, depending on the sufficiency status of fulfilled sufficient
causes. (Without specifying any causes, the function prints a list of
all available ones in the console.)</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>scc_model <span class="sc">%&gt;%</span> <span class="fu">are_sufficient</span>(<span class="fu">c</span>(<span class="st">&quot;THENa5d1&quot;</span>,<span class="st">&quot;THENa4d1&quot;</span>,<span class="st">&quot;THENa6d1&quot;</span>,<span class="st">&quot;THENa7d3e4&quot;</span>), <span class="at">type =</span> <span class="st">&quot;status&quot;</span>)</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="co">#&gt; [1] &quot;always&quot;</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>scc_model <span class="sc">%&gt;%</span> <span class="fu">are_sufficient</span>(<span class="fu">c</span>(<span class="st">&quot;THENa5d1&quot;</span>,<span class="st">&quot;THENa4d1&quot;</span>,<span class="st">&quot;THENa6d1&quot;</span>,<span class="st">&quot;THENa7d3e4&quot;</span>), <span class="at">type =</span> <span class="st">&quot;binary&quot;</span>)</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
</div>
<div id="extract-necessary-causes" class="section level2">
<h2>Extract necessary causes</h2>
<p>Necessary causes, i.e., component causes that are part of every
sufficient cause, can be extracted with function
<code>necessary_causes()</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>scc_model <span class="sc">%&gt;%</span> <span class="fu">necessary_causes</span>()</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="co">#&gt; [1] &quot;THENa4d1&quot; &quot;THENa6d1&quot;</span></span></code></pre></div>
</div>
</div>
<div id="references" class="section level1">
<h1>References</h1>
<ul>
<li>Irvine AD, McLean WHI, Leung DYM (2011): <em>Filaggrin mutations
associated with skin and allergic diseases.</em> The New England Journal
of Medicine 365(14):1315-1327.</li>
<li>Pearl J (2009): <em>Causality: Models, reasoning, and
inference.</em> Cambridge: Univ. Press.</li>
<li>Rerknimitr P, Otsuka A, Nakashima C, Kabashima K (2017): <em>The
etiopathogenesis of atopic dermatitis: barrier disruption, immunological
derangement, and pruritus.</em> Inflammation and Regeneration
37:14.</li>
<li>Rothman KJ (1976): <em>Causes</em>. American Journal of Epidemiology
104(6):587-592.</li>
<li>Rothman KJ, Greenland S, Poole C, Lash TL (2008): <em>Causation and
Causal Inference.</em> In: Rothman KJ, Greenland S, Lash TL (Ed.):
<em>Modern epidemiology.</em> Third edition. Philadelphia, Baltimore,
New York: Wolters Kluwer Health Lippincott Williams &amp; Wilkins,
pp. 5–31.</li>
</ul>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
